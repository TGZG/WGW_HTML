### 灵根
灵根，象征着修士的修炼天赋，影响修士学习术法、炼化灵气的速度。
### 灵根变化
灵根，天生就有，后天通常不变。
【补天丹】可以后天提升灵根，价格天价、有价无市，其几味主药亦是有价无市，是各大圣地囤积的底蕴。
### 灵根测试
通常来说，灵根越少越好。单灵根又名天灵根，五灵根又名杂灵根。
灵根底层是五个值，表示金木水火土五系，每个值在0-100，表层不可见。
测试具体的值很难，但测试【有几个灵根断崖式领先（跨度超20）其他灵根】容易。并且大多数人灵根总值为150左右，导致：
- 如果有一个断崖领先，那么其值通常接近90；
- 如果有两个断崖领先，那么其值通常接近60；
- 如果有三个断崖领先，那么其值通常接近43；
- 如果有四个断崖领先，那么其值通常接近35；
- 如果有五个断崖领先，那么其值通常接近30；
一个为天灵根，两个为双灵根，三个为三灵根，四五个统称杂灵根。只有这三种人会被称之为有修炼天赋、被势力招收，甚至很多大势力也不招收三灵根的弟子。
### 灵根命名
- 灵根数量：天灵感、双灵根、三灵根、杂灵根（四灵根、五灵根）
	- 金系天灵根
	- 火木双灵根
	- 金水土三灵根
- 灵根主度
	- 金系天灵根。别名：金系单主天灵根、金系主灵根、金系单主灵根、主金灵根、金主灵根、金主天灵根、金灵根、金系单灵根
	- 火木单主双灵根。别名：火木主次双灵根
	- 火木双主灵根。别名：火木双主双灵根
	- 金水土单主三灵根。别名：金水土主次三灵根、金水土主次次三灵根
	- 金水土双主三灵根
	- 金水土三主灵根。别名：金水土三主三灵根
### 水晶球
测试使用水晶球。不同型号的水晶球有不同的效果，包括这几个参数：
- 跨度。表示断崖领先的跨度阈值。通常为20。数值越高、成本越低，但是高数值与低数值都没意义，20是修真界的标准规范、以20来划分天灵根双灵根。
- 浓度。通常为10。浓度10表示：
	- 当灵根为【60，45，30，10，5】的时候，会显示为【三灵根，超浓、浓、淡】，因为这三个灵根内部跨度超过10。
	- 当灵根为【45，40，35，15，15】的时候，会显示为【三灵根，淡，淡，淡】，因为这三个灵根相邻内部跨度都不超过10。
	- 当测试结果显示【多灵根但有浓色】的时候，表示天赋超越一般的此灵根。例如，【三灵根，超浓、浓、淡】通常会被视为【伪二灵根】看待。
- //光度。便宜的通常为【0 0 0 0 0】，昂贵的通常为【80 60 40 20 0】。昂贵的表示：当某个灵根的数值大于80时，光度会达到非常耀眼；当某个灵根数值只有10时，会非常暗淡。便宜的表示，无论灵根数值多少，光度都一样（可以都耀眼或都暗淡）。（争议：这会导致天灵根划分失去意义，只看光度就够了）
- 寿命。通常为100。表示一般的测试可以进行100次。
- 力竭阈值。通常为80-200。表示当灵根单值超过80、或总值超过200时，消耗三倍寿命。
- 损坏阈值。通常为90-250。表示当灵根单值超过90、或总值超过250时，消耗九倍寿命。
- 破碎阈值。通常为95-300。表示当灵根单值超过95、或总值超过300时，消耗二十七倍寿命。
### 灵根生成
灵根总量会以偏态分布的形式，在0到500之间生成，以150为中心。
- 68%的人，灵根在136到169之间。
- 95%的人，灵根在126到196之间。
- 99.7%的人，灵根在118到239之间。
生成总量之后，随机分配在五个灵根上，使用投球算法：把五个灵根视为五个壶，总量视为球数，每一次投一个球进入一个随机的壶，直至所有球都投光；如果期间某个壶投满了100个，那么后续不投它。
- 天灵根概率：
- 双灵根概率：
- 三灵根概率：
### 灵根生成：公式推导
总量的具体公式为：灵根总量=Clamp(100+50exp((-2lnC1)^0.5 × cos(2πC2)/3) , 0 , 500)，其中C1与C2为0-1之间的随机数
推导过程：
- 明确分布中心：150
- 明确偏态系数：3
- 明确缩放因子：50
- 标准正态分布：(-2lnC1)^0.5 × cos(2πC2)，其中C1与C2为0-1之间的随机数
- 偏态变换到左紧右松：F(X)=exp(X/3)
- 线性变换到分布中心：F(X)=150+(X-1)×50=100+50X
- 上下限约束：F(X)=Clamp(X , 0 , 500)
- 最终公式：灵根总量=Clamp(100+50exp((-2lnC1)^0.5 × cos(2πC2)/3) , 0 , 500)，其中C1与C2为0-1之间的随机数
如果需要调整数值，那么只需调整开头的三个参数：分布中心、偏态系数、缩放因子。
分布中心影响平均数，偏态系数影响左右不平衡度，缩放因子影响步幅。
### 代码
运行结果：
样本数：100000

天灵根：0.01%
平均分布：145.27 [75.62, 21.62, 19.24, 15.89, 12.91]
最高峰值：88.53(174.00) [88.53, 26.04, 26.04, 19.94, 13.45]
最低峰值：61.69(121.00) [61.69, 17.76, 17.76, 11.89, 11.89]
最高主度：0.00(151.00) [80.65, 22.51, 20.93, 16.54, 10.37]
最低主度：0.00(151.00) [80.65, 22.51, 20.93, 16.54, 10.37]
最高总量：174.00 [88.53, 26.04, 26.04, 19.94, 13.45]
最低总量：121.00 [61.69, 17.76, 17.76, 11.89, 11.89]

双灵根：0.18%
平均分布：143.56 [65.16, 31.75, 17.85, 15.79, 13.02]
最高峰值：85.50(187.00) [85.50, 33.63, 23.61, 23.61, 20.66]
最低峰值：47.73(125.00) [47.73, 45.19, 13.95, 11.30, 6.83]
最高主度：58.24(141.00) [85.04, 26.80, 23.56, 20.52, 15.08]
最低主度：0.00(138.00) [51.09, 51.09, 12.77, 11.53, 11.53]
最高总量：187.00 [85.50, 33.63, 23.61, 23.61, 20.66]
最低总量：117.00 [48.74, 36.14, 13.58, 12.19, 6.36]

三灵根：1.66%
平均分布：146.08 [57.19, 35.08, 25.80, 15.38, 12.62]
最高峰值：91.49(214.00) [91.49, 45.82, 28.07, 25.03, 23.58]
最低峰值：38.67(124.00) [38.67, 31.76, 31.76, 10.91, 10.91]
最高主度：109.09(134.00) [91.49, 45.82, 28.07, 25.03, 23.58]
最低主度：2.27(144.00) [41.45, 41.45, 39.18, 11.55, 10.36]
最高总量：214.00 [91.49, 45.82, 28.07, 25.03, 23.58]
最低总量：118.00 [51.88, 25.62, 21.83, 12.28, 6.40]

四灵根：13.31%
平均分布：148.54 [49.28, 35.91, 28.67, 22.46, 12.22]
最高峰值：85.43(221.00) [85.43, 37.97, 37.97, 36.18, 23.44]
最低峰值：30.64(123.00) [30.64, 30.64, 28.49, 24.43, 8.79]
最高主度：161.10(130.00) [83.16, 36.34, 26.02, 26.02, 24.46]
最低主度：0.00(138.00) [32.83, 32.83, 32.83, 32.83, 6.70]
最高总量：252.00 [80.38, 59.66, 51.44, 38.52, 21.99]
最低总量：113.00 [47.01, 27.49, 14.68, 14.68, 9.15]

五灵根：84.84%
平均分布：153.62 [42.94, 35.21, 29.92, 25.27, 20.29]
最高峰值：93.94(282.00) [93.94, 65.95, 44.62, 41.19, 36.30]
最低峰值：25.71(121.00) [25.71, 25.71, 25.71, 25.71, 18.14]
最高主度：222.65(161.00) [84.53, 33.90, 30.43, 25.57, 25.57]
最低主度：0.00(130.00) [26.00, 26.00, 26.00, 26.00, 26.00]
最高总量：341.00 [87.96, 77.05, 70.85, 62.98, 42.16]
最低总量：111.00 [27.85, 27.85, 19.65, 17.82, 17.82]
``` C#
using System;
using System.Linq;
using System.Collections.Generic;
using static 灵根分析.LocalStorage;
using CMKZ;

namespace 灵根分析 {
    public static partial class LocalStorage {
        public static double 偏态分布(double 中心值, double 偏态值, double 步幅值) {
            var C1 = new Random().NextDouble();
            var C2 = new Random().NextDouble();
            var 数值 = 中心值 + (Math.Exp(Math.Sqrt(-2 * Math.Log(C1)) * Math.Cos(2 * Math.PI * C2) / 偏态值) - 1) * 步幅值;
            return Math.Max(0, Math.Min(500, 数值));
        }
        public static int ToInt(this double value) {
            return (int)Math.Round(value);
        }
        public static double[] Add(this double[] a, double[] b) {
            return a.Zip(b, (x, y) => x + y).ToArray();
        }
        public static string ToString<T>(this IEnumerable<T> source, Func<T, string> selector, string separator) {
            return string.Join(separator, source.Select(selector));
        }
    }
    public static partial class LocalStorage {
        public const double 幂次 = 2;
        public const double 断崖 = 0.7;
        public const int 样本数 = 100000;
    }
    public enum 灵根类型 {
        天灵根 = 1,
        双灵根 = 2,
        三灵根 = 3,
        四灵根 = 4,
        五灵根 = 5,
    }
    public class 灵根 {
        public double[] 数值;
        public int 总量;
        public 灵根类型 类型;
        public int 主数;
        public double 主度;//越小越好
        public const double 幂次 = LocalStorage.幂次;
        public const double 断崖 = LocalStorage.断崖;
        public 灵根(int 总量) {
            this.总量 = 总量;
            数值 = 生成并归一化();
            类型 = 分析类型();
            主数 = 分析主数();
            主度 = 分析主度();
        }
        private double[] 生成并归一化() {
            var 灵根值 = new double[5];
            var 剩余桶 = new HashSet<int> { 0, 1, 2, 3, 4 };
            int 剩余点数 = 总量;
            while (剩余点数 > 0 && 剩余桶.Count > 0) {
                var 可选桶 = 剩余桶.ToArray();
                var 选中桶 = 可选桶[new Random().Next(可选桶.Length)];
                灵根值[选中桶]++;
                if (灵根值[选中桶] >= 100)
                    剩余桶.Remove(选中桶);
                剩余点数--;
            }
            return 调整分布(灵根值);
        }
        //还需要避免数值超过100，超出的随机分配给其他的。建议抽离出一个分配函数，用于生成与此处。
        private double[] 调整分布(double[] 灵根值) {
            var 变换后 = 灵根值.Select(x => Math.Pow(x, 幂次));
            var 总和 = 变换后.Sum();
            return [.. 变换后.Select(x => Math.Round(x * 总量 / 总和, 2)).OrderByDescending(x => x)];
        }
        public 灵根类型 分析类型() {
            int A = 0;
            for (int i = 0; i < 数值.Length; i++) {
                if (数值[0] - 数值[i] >= 数值[0] * 断崖) {
                    A = i;
                    break;
                }
            }
            return A switch {
                0 => 灵根类型.五灵根,
                1 => 灵根类型.天灵根,
                2 => 灵根类型.双灵根,
                3 => 灵根类型.三灵根,
                4 => 灵根类型.四灵根,
                _ => throw new Exception("灵根类型错误")
            };
        }
        public int 分析主数() {
            return 数值.Count(x => x >= 数值[0] * 0.8);
        }
        public double 分析主度() {
            return 数值.Take((int)类型).Select(x => 数值[0] - x).Sum();
        }
    }
    public class 分析结果 {
        public 灵根类型 类型;
        public int 样本数量;//一万个
        public int 本类数量;//一万个里面有10个天灵根
        public double 总量和;//10个的和
        public double[] 五值和 = new double[5];

        public double 最高峰值;
        public double 最高峰值总量;
        public double[] 最高峰值案例 = new double[5];

        public double 最低峰值;
        public double 最低峰值总量;
        public double[] 最低峰值案例 = new double[5];

        public double 最高总量;
        public double[] 最高总量案例 = new double[5];
        public double 最低总量;
        public double[] 最低总量案例 = new double[5];

        public double 最高主度;
        public double 最高主度总量;
        public double[] 最高主度案例 = new double[5];

        public double 最低主度;
        public double 最低主度总量;
        public double[] 最低主度案例 = new double[5];


        private double 出现率 => 本类数量 * 100d / 样本数量;//0.1%
        private double 平均总量 => 总量和 / 本类数量;
        private double[] 平均五值 => 五值和.Select(x => x / 本类数量).ToArray();
        public void Eat(灵根 X) {
            本类数量++;
            总量和 += X.总量;
            五值和 = 五值和.Add(X.数值);
            CheckFirstEat(X);
            if (X.数值[0] > 最高峰值) {
                最高峰值 = X.数值[0];
                最高峰值总量 = X.总量;
                最高峰值案例 = X.数值;
            }
            if (X.数值[0] < 最低峰值) {
                最低峰值 = X.数值[0];
                最低峰值总量 = X.总量;
                最低峰值案例 = X.数值;
            }
            if (X.主度 < 最低主度) {
                最低主度 = X.主度;
                最低主度总量 = X.总量;
                最低主度案例 = X.数值;
            }
            if (X.主度 > 最高主度) {
                最高主度 = X.主度;
                最高主度案例 = X.数值;
            }
            if (X.总量 > 最高总量) {
                最高总量 = X.总量;
                最高总量案例 = X.数值;
            }
            if (X.总量 < 最低总量) {
                最低总量 = X.总量;
                最低总量案例 = X.数值;
            }
        }
        public bool IsInit;
        public void CheckFirstEat(灵根 X) {
            if (!IsInit) {
                IsInit = true;
                最高峰值 = X.数值[0];
                最高峰值总量 = X.总量;
                最高峰值案例 = X.数值;
                最低峰值 = X.数值[0];
                最低峰值总量 = X.总量;
                最低峰值案例 = X.数值;
                最低主度 = X.主度;
                最低主度总量 = X.总量;
                最低主度案例 = X.数值;
                最高主度 = X.主度;
                最高主度总量 = X.总量;
                最高主度案例 = X.数值;
                最高总量 = X.总量;
                最高总量案例 = X.数值;
                最低总量 = X.总量;
                最低总量案例 = X.数值;
            }
        }
        public override string ToString() {
            return $"{类型}：{出现率:F2}%\n" +
                   $"平均分布：{平均总量:F2} [{平均五值.ToString(t => t.ToString("F2"), ", ")}]\n" +
                   $"最高峰值：{最高峰值:F2}({最高峰值总量:F2}) [{最高峰值案例.ToString(t => t.ToString("F2"), ", ")}]\n" +
                   $"最低峰值：{最低峰值:F2}({最低峰值总量:F2}) [{最低峰值案例.ToString(t => t.ToString("F2"), ", ")}]\n" +
                   $"最高主度：{最高主度:F2}({最高主度总量:F2}) [{最高主度案例.ToString(t => t.ToString("F2"), ", ")}]\n" +
                   $"最低主度：{最低主度:F2}({最低主度总量:F2}) [{最低主度案例.ToString(t => t.ToString("F2"), ", ")}]\n" +
                   $"最高总量：{最高总量:F2} [{最高总量案例.ToString(t => t.ToString("F2"), ", ")}]\n" +
                   $"最低总量：{最低总量:F2} [{最低总量案例.ToString(t => t.ToString("F2"), ", ")}]\n";
        }
    }
    public class 灵根分析器(int X = 样本数) {
        public int 样本数量 = X;
        public Dictionary<灵根类型, 分析结果> 各灵根 = [];
        public void 运行分析() {
            各灵根[灵根类型.天灵根] = new 分析结果 { 类型 = 灵根类型.天灵根, 样本数量 = 样本数量 };
            各灵根[灵根类型.双灵根] = new 分析结果 { 类型 = 灵根类型.双灵根, 样本数量 = 样本数量 };
            各灵根[灵根类型.三灵根] = new 分析结果 { 类型 = 灵根类型.三灵根, 样本数量 = 样本数量 };
            各灵根[灵根类型.四灵根] = new 分析结果 { 类型 = 灵根类型.四灵根, 样本数量 = 样本数量 };
            各灵根[灵根类型.五灵根] = new 分析结果 { 类型 = 灵根类型.五灵根, 样本数量 = 样本数量 };
            for (int i = 0; i < 样本数量; i++) {
                var A = new 灵根(偏态分布(150, 3, 50).ToInt());
                各灵根[A.类型].Eat(A);//丑陋。应该把那个字典作为一个类。
            }
        }
        public void 输出结果() {
            Console.WriteLine($"样本数：{样本数量}\n");
            foreach (var i in 各灵根) {
                Console.WriteLine(i.Value.ToString());
            }
        }
    }
    class Program {
        static void Main(string[] args) {
            var 分析器 = new 灵根分析器();
            分析器.运行分析();
            分析器.输出结果();
            Console.WriteLine("\n按任意键退出...");
            Console.ReadKey();
        }
    }
}
```